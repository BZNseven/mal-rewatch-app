<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>BZN7 Rewatch Curator</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; margin: 2rem; }
    button { padding: .6rem 1rem; border-radius: .5rem; border: 1px solid #ccc; cursor: pointer; margin-right:.5rem; }
    input[type="text"] { padding:.4rem .6rem; border-radius:.4rem; border:1px solid #ccc; min-width:240px; }
    table { border-collapse: collapse; width: 100%; margin-top: 1rem; }
    th, td { border: 1px solid #ddd; padding: .5rem; }
    th { background: #f7f7f7; text-align: left; }
    .muted { color: #777; margin-left: .5rem; }
    .row { display:flex; flex-wrap:wrap; gap:.75rem; align-items:center; }
    label { white-space:nowrap; }
    #diag { margin-top:1rem; font-size:.95rem; }
    #diag ul { margin:.4rem 0 0 1.2rem; }
  </style>
</head>
<body>
  <h1>Rewatch Curator (MAL)</h1>

  <div id="auth" class="row">
    <button onclick="location.href='/auth/start'">Sign in with MAL</button>
    <button onclick="logout()">Logout</button>
    <span id="status" class="muted"></span>
  </div>

  <div id="controls" class="row" style="margin-top:1rem;">
    <label><input type="checkbox" id="gateCompleted" checked /> Completed only</label>
    <label>Tag:
      <select id="tagToken">
        <option value="Rewatch" selected>Rewatch</option>
        <option value="rw-list">rw-list</option>
      </select>
    </label>
    <button id="load">Load List</button>
    <button id="exportCsv">Download CSV</button>
    <button id="exportMd">Download Markdown</button>
    <button id="copyMd">Copy Markdown</button>
    <button id="debug">Debug Counts</button>
    <button id="missing">Explain Missing</button>
  </div>

  <div class="row" style="margin-top:.5rem;">
    <label>Find titles with tag token:
      <input id="variantToken" type="text" placeholder="e.g., rewwatch" />
    </label>
    <button id="findVariant">Find</button>

    <label>XML diff (upload old export): 
      <input id="xmlFile" type="file" accept=".xml,text/xml" />
    </label>
    <button id="xmlDiff">Find 'Rewatch' lost vs live</button>
  </div>

  <table id="tbl" style="display:none;">
    <thead>
      <tr>
        <th>Title</th><th>My Score</th><th>Genres</th><th>Year</th><th>Type</th><th>Ep</th><th>Studios</th><th>Link</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <div id="diag" class="muted"></div>

<script>
let LAST_ROWS = [];           // filtered + sorted rows currently shown
let LAST_DETAILS = new Map(); // id -> details (genres/studios/etc)
let LAST_ALL_ITEMS = [];      // raw items from MAL (unfiltered)

// ——— helpers ———
async function logout() {
  await fetch("/api/logout");
  document.getElementById("status").textContent = "Logged out.";
}

function splitListCSV(value) {
  return (value || "")
    .split(",")
    .map(s => s.trim())
    .filter(Boolean);
}

function listStatusTokens(ls) {
  if (!ls || !ls.tags) return [];
  return splitListCSV(ls.tags.join(","));
}

function tokenHasTag(ls, tagToken) {
  const t = (tagToken || "").trim().toLowerCase();
  if (!t) return false;
  return listStatusTokens(ls).map(x => x.toLowerCase()).includes(t);
}

function statusName(s) {
  return (s || "").toLowerCase() || "unknown";
}

async function fetchAllList() {
  const rows = [];
  let offset = 0;
  const limit = 100;
  const fields = "list_status{tags,score,status,is_rewatching,num_times_rewatched,rewatch_value}";
  while (true) {
    const url = `/api/animelist?limit=${limit}&offset=${offset}&fields=${encodeURIComponent(fields)}`;
    const r = await fetch(url);
    if (r.status === 401) throw new Error("Not signed in.");
    if (!r.ok) throw new Error("Animelist error: " + (await r.text()));
    const j = await r.json();
    (j.data || []).forEach(item => rows.push(item));
    if (!j.paging || !j.paging.next) break;
    offset += limit;
  }
  return rows;
}

async function enrichOne(id) {
  const u = `/api/anime/${id}?fields=genres,studios,start_season,num_episodes,media_type`;
  const r = await fetch(u);
  if (!r.ok) return null;
  return r.json();
}

function toDisplayRow(row, details) {
  const n = row.node;
  const ls = row.list_status || {};
  const d = details || {};
  const title = n.title_english || n.title || "—";
  const score = (ls.score && ls.score !== 0) ? ls.score : "—";
  const genresArr = (d.genres || []).slice(0,3).map(g => g.name);
  const studiosArr = (d.studios || []).slice(0,2).map(s => s.name);
  const year = (d.start_season && d.start_season.year) ? d.start_season.year : "";
  const type = d.media_type || n.media_type || "";
  const ep = (typeof d.num_episodes === "number") ? d.num_episodes : (n.num_episodes || "");
  const link = `https://myanimelist.net/anime/${n.id}`;
  return { title, score, genresArr, year, type, ep, studiosArr, link, id: n.id };
}

function render(rows, detailsMap) {
  const tbody = document.querySelector("#tbl tbody");
  tbody.innerHTML = "";
  for (const row of rows) {
    const d = detailsMap.get(row.node.id);
    const v = toDisplayRow(row, d);
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${v.title}</td>
      <td style="text-align:right">${v.score}</td>
      <td>${v.genresArr.join(", ")}</td>
      <td style="text-align:right">${v.year||""}</td>
      <td>${v.type||""}</td>
      <td style="text-align:right">${v.ep||""}</td>
      <td>${v.studiosArr.join(", ")}</td>
      <td><a href="${v.link}" target="_blank">MAL</a></td>`;
    tbody.appendChild(tr);
  }
  document.getElementById("tbl").style.display = "";
}

function download(filename, text, mime) {
  const blob = new Blob([text], { type: mime || "text/plain;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function generateCSV(rows, detailsMap) {
  const headers = ["Title","My Score","Genres","Year","Type","Ep","Studios","Link"];
  const lines = [headers.join(",")];
  for (const row of rows) {
    const v = toDisplayRow(row, detailsMap.get(row.node.id));
    const title = `"${(v.title || "").replace(/"/g, '""')}"`;
    const score = v.score === "—" ? "" : v.score;
    const genres = `"${v.genresArr.join("; ").replace(/"/g, '""')}"`;
    const studios = `"${v.studiosArr.join("; ").replace(/"/g, '""')}"`;
    const year = v.year || "";
    const type = `"${(v.type||"").replace(/"/g, '""')}"`;
    const ep = v.ep || "";
    const link = v.link;
    lines.push([title, score, genres, year, type, ep, studios, link].join(","));
  }
  return lines.join("\n");
}

function generateMarkdown(rows, detailsMap) {
  const header = "| Title | My Score | Genres | Year | Type | Ep | Studios | Link |\n|---|---:|---|---:|---|---:|---|---|";
  const lines = [header];
  for (const row of rows) {
    const v = toDisplayRow(row, detailsMap.get(row.node.id));
    const score = v.score === "—" ? "—" : String(v.score);
    lines.push(`| ${v.title} | ${score} | ${v.genresArr.join(", ")} | ${v.year||""} | ${v.type||""} | ${v.ep||""} | ${v.studiosArr.join(", ")} | ${v.link} |`);
  }
  return lines.join("\n");
}

// ——— main actions ———
document.getElementById("load").addEventListener("click", async () => {
  try {
    document.getElementById("status").textContent = "Loading…";
    document.getElementById("diag").textContent = "";
    LAST_ROWS = [];
    LAST_DETAILS = new Map();

    const gateCompleted = document.getElementById("gateCompleted").checked;
    const tagToken = document.getElementById("tagToken").value;

    const items = await fetchAllList();
    LAST_ALL_ITEMS = items.slice(); // keep raw set for diagnostics

    // Filter to exact tag + (optional) completed
    const filt = items.filter(x => {
      const ls = x.list_status || {};
      const hasTag = tokenHasTag(ls, tagToken);
      const done = !gateCompleted || (ls.status && ls.status.toLowerCase() === "completed");
      return hasTag && done;
    });

    // Sort by score desc (0 lowest), then title asc
    const rows = filt.slice().sort((a,b) => {
      const sa = a.list_status.score || 0, sb = b.list_status.score || 0;
      if (sb !== sa) return sb - sa;
      const ta = (a.node.title_english || a.node.title || "").toLowerCase();
      const tb = (b.node.title_english || b.node.title || "").toLowerCase();
      return ta.localeCompare(tb);
    });

    LAST_ROWS = rows;

    // Enrich a safe chunk to avoid rate limits
    const MAX_DETAILS = 50;
    const toEnrich = rows.slice(0, MAX_DETAILS);
    for (const x of toEnrich) {
      const d = await enrichOne(x.node.id);
      if (d) LAST_DETAILS.set(x.node.id, d);
    }

    render(rows, LAST_DETAILS);
    document.getElementById("status").textContent =
      `Loaded ${filt.length} items; showing ${rows.length}. Details fetched for ${LAST_DETAILS.size}.`;
  } catch (e) {
    document.getElementById("status").textContent = e.message || "Error.";
  }
});

// Exports
document.getElementById("exportCsv").addEventListener("click", () => {
  if (!LAST_ROWS.length) return (document.getElementById("status").textContent = "Load the list first.");
  const csv = generateCSV(LAST_ROWS, LAST_DETAILS);
  download("rewatch_list.csv", csv, "text/csv;charset=utf-8;");
});

document.getElementById("exportMd").addEventListener("click", () => {
  if (!LAST_ROWS.length) return (document.getElementById("status").textContent = "Load the list first.");
  const md = generateMarkdown(LAST_ROWS, LAST_DETAILS);
  download("rewatch_list.md", md, "text/markdown;charset=utf-8;");
});

document.getElementById("copyMd").addEventListener("click", async () => {
  if (!LAST_ROWS.length) return (document.getElementById("status").textContent = "Load the list first.");
  const md = generateMarkdown(LAST_ROWS, LAST_DETAILS);
  try {
    await navigator.clipboard.writeText(md);
    document.getElementById("status").textContent = "Markdown copied to clipboard.";
  } catch {
    const ta = document.createElement("textarea");
    ta.value = md;
    document.body.appendChild(ta);
    ta.select();
    const ok = document.execCommand("copy");
    ta.remove();
    document.getElementById("status").textContent = ok ? "Markdown copied (fallback)." : "Clipboard blocked — use Download Markdown instead.";
  }
});

// Diagnostics: counts
document.getElementById("debug").addEventListener("click", () => {
  if (!LAST_ALL_ITEMS.length) {
    document.getElementById("status").textContent = "Load the list first.";
    return;
  }
  const tagToken = document.getElementById("tagToken").value.toLowerCase();
  const tagCounts = new Map();
  const statusCounts = new Map();
  for (const it of LAST_ALL_ITEMS) {
    const tags = listStatusTokens(it.list_status).map(t => t.toLowerCase());
    for (const t of tags) tagCounts.set(t, (tagCounts.get(t)||0) + 1);
    if (tags.includes(tagToken)) {
      const st = statusName(it.list_status && it.list_status.status);
      statusCounts.set(st, (statusCounts.get(st)||0) + 1);
    }
  }
  const tagLines = [...tagCounts.entries()].sort((a,b)=>b[1]-a[1]).map(([t,c])=>`${t||"(empty)"}: ${c}`).join(" • ");
  const stLines  = [...statusCounts.entries()].sort((a,b)=>b[1]-a[1]).map(([s,c])=>`${s}: ${c}`).join(" • ");
  document.getElementById("status").textContent =
    `Tag variants seen → ${tagLines || "none"}  ||  By status for “${tagToken}” → ${stLines || "none"}`;
});

// Diagnostics: explain missing
document.getElementById("missing").addEventListener("click", () => {
  if (!LAST_ALL_ITEMS.length) {
    document.getElementById("status").textContent = "Load the list first.";
    return;
  }
  const gateCompleted = document.getElementById("gateCompleted").checked;
  const tagToken = document.getElementById("tagToken").value.toLowerCase();

  const reasons = { notCompleted: [], tagMismatch: [] };
  for (const it of LAST_ALL_ITEMS) {
    const ls = it.list_status || {};
    const tags = listStatusTokens(ls).map(t => t.toLowerCase());
    const hasTag = tags.includes(tagToken);
    const done = ls.status && ls.status.toLowerCase() === "completed";
    if (!hasTag) reasons.tagMismatch.push(it.node.title_english || it.node.title || `ID ${it.node.id}`);
    else if (gateCompleted && !done) reasons.notCompleted.push(it.node.title_english || it.node.title || `ID ${it.node.id}`);
  }
  const top5 = (arr) => arr.slice(0,5).join(" | ") + (arr.length > 5 ? ` …(+${arr.length-5})` : "");
  document.getElementById("status").textContent =
    `Excluded — Tag mismatch: ${reasons.tagMismatch.length} (e.g., ${top5(reasons.tagMismatch)}) | Not completed: ${reasons.notCompleted.length} (e.g., ${top5(reasons.notCompleted)})`;
});

// NEW: list titles that contain an exact tag token (e.g., "rewwatch")
document.getElementById("findVariant").addEventListener("click", () => {
  const token = (document.getElementById("variantToken").value || "").trim().toLowerCase();
  if (!token) { document.getElementById("diag").textContent = "Enter a tag token (e.g., rewwatch)."; return; }
  if (!LAST_ALL_ITEMS.length) { document.getElementById("status").textContent = "Load the list first."; return; }
  const matches = LAST_ALL_ITEMS.filter(it =>
    listStatusTokens(it.list_status).map(t => t.toLowerCase()).includes(token)
  );
  const ul = matches.map(it => {
    const title = it.node.title_english || it.node.title || `ID ${it.node.id}`;
    const link = `https://myanimelist.net/anime/${it.node.id}`;
    return `<li><a href="${link}" target="_blank">${title}</a></li>`;
  }).join("");
  document.getElementById("diag").innerHTML =
    matches.length ? `<b>Titles tagged “${token}” (${matches.length}):</b><ul>${ul}</ul>` :
                     `No titles found with tag “${token}”.`;
});

// NEW: XML diff — find entries that had Rewatch in the XML but not in live MAL now
function parseMalXML(text) {
  const out = [];
  try {
    const doc = new DOMParser().parseFromString(text, "application/xml");
    const nodes = doc.getElementsByTagName("anime");
    for (let i = 0; i < nodes.length; i++) {
      const n = nodes[i];
      const id = (n.getElementsByTagName("series_animedb_id")[0]?.textContent || "").trim();
      const title = (n.getElementsByTagName("series_title")[0]?.textContent || "").trim();
      const status = (n.getElementsByTagName("my_status")[0]?.textContent || "").trim();
      const tags = (n.getElementsByTagName("my_tags")[0]?.textContent || "").trim();
      out.push({ id, title, status, tags });
    }
  } catch (e) {}
  return out;
}

function statusIsCompletedXML(s) {
  const v = (s || "").trim().toLowerCase();
  return v === "completed" || v === "2"; // MAL XML sometimes uses words; sometimes codes
}

document.getElementById("xmlDiff").addEventListener("click", async () => {
  const file = document.getElementById("xmlFile").files[0];
  if (!file) { document.getElementById("diag").textContent = "Choose your MAL XML export file first."; return; }
  const text = await file.text();
  const rows = parseMalXML(text);
  if (!rows.length) { document.getElementById("diag").textContent = "Could not parse XML."; return; }

  // XML set: exact 'Rewatch' tag + Completed (robust split)
  const xmlRewatch = new Set();
  const xmlMap = new Map();
  for (const r of rows) {
    const hasRewatch = splitListCSV(r.tags).map(t => t.toLowerCase()).includes("rewatch");
    const isDone = statusIsCompletedXML(r.status);
    if (hasRewatch && isDone && r.id) {
      xmlRewatch.add(r.id);
      xmlMap.set(r.id, r.title || `ID ${r.id}`);
    }
  }

  // Live MAL set (current filter): exact Rewatch + Completed
  if (!LAST_ROWS.length) { document.getElementById("status").textContent = "Load the list first."; return; }
  const liveSet = new Set(LAST_ROWS.map(r => String(r.node.id)));

  // lost = in XML Rewatch but not in current live Rewatch
  const lost = [...xmlRewatch].filter(id => !liveSet.has(String(id)));

  if (!lost.length) {
    document.getElementById("diag").innerHTML = "<b>No differences:</b> All XML ‘Rewatch’ (Completed) entries are present in your live MAL ‘Rewatch’.";
    return;
  }

  const items = lost.slice(0, 50).map(id => {
    const t = xmlMap.get(id) || `ID ${id}`;
    const link = `https://myanimelist.net/anime/${id}`;
    return `<li><a href="${link}" target="_blank">${t}</a></li>`;
  }).join("");

  document.getElementById("diag").innerHTML =
    `<b>Likely lost ‘Rewatch’ tag since your XML export:</b> ${lost.length} item(s).
     <ul>${items}</ul>
     ${lost.length > 50 ? "<i>(showing first 50)</i>" : ""}`;
});
</script>
</body>
</html>
