<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>BZN7 Rewatch Curator</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; margin: 2rem; }
    button { padding: .6rem 1rem; border-radius: .5rem; border: 1px solid #ccc; cursor: pointer; margin-right:.5rem; }
    table { border-collapse: collapse; width: 100%; margin-top: 1rem; }
    th, td { border: 1px solid #ddd; padding: .5rem; }
    th { background: #f7f7f7; text-align: left; }
    .muted { color: #777; margin-left: .5rem; }
  </style>
</head>
<body>
  <h1>Rewatch Curator (MAL)</h1>

  <div id="auth">
    <button onclick="location.href='/auth/start'">Sign in with MAL</button>
    <button onclick="logout()">Logout</button>
    <span id="status" class="muted"></span>
  </div>

  <div id="controls" style="margin-top:1rem;">
    <label><input type="checkbox" id="gateCompleted" checked /> Completed only</label>
    <label style="margin-left:1rem;">Tag:
      <select id="tagToken">
        <option value="Rewatch" selected>Rewatch</option>
        <option value="rw-list">rw-list</option>
      </select>
    </label>
    <button id="load">Load List</button>
    <button id="exportCsv">Download CSV</button>
    <button id="exportMd">Download Markdown</button>
    <button id="copyMd">Copy Markdown</button>
    <button id="debug">Debug Counts</button>
    <button id="missing">Explain Missing</button>
  </div>

  <table id="tbl" style="display:none;">
    <thead>
      <tr>
        <th>Title</th><th>My Score</th><th>Genres</th><th>Year</th><th>Type</th><th>Ep</th><th>Studios</th><th>Link</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

<script>
let LAST_ROWS = [];           // filtered + sorted rows currently shown
let LAST_DETAILS = new Map(); // id -> details (genres/studios/etc)
let LAST_ALL_ITEMS = [];      // raw items from MAL (unfiltered)

// ——— helpers ———
async function logout() {
  await fetch("/api/logout");
  document.getElementById("status").textContent = "Logged out.";
}

function tokenHasTag(listStatus, tagToken) {
  if (!listStatus || !listStatus.tags) return false;
  // MAL returns tags as an array of strings. We normalize to tokens.
  return listStatus.tags
    .join(",")
    .split(",")
    .map(s => s.trim().toLowerCase())
    .includes(tagToken.toLowerCase());
}

function splitTags(listStatus) {
  if (!listStatus || !listStatus.tags) return [];
  return listStatus.tags
    .join(",")
    .split(",")
    .map(s => s.trim())
    .filter(Boolean);
}

function statusName(s) {
  return (s || "").toLowerCase() || "unknown";
}

async function fetchAllList() {
  const rows = [];
  let offset = 0;
  const limit = 100;
  const fields = "list_status{tags,score,status,is_rewatching,num_times_rewatched,rewatch_value}";
  while (true) {
    const url = `/api/animelist?limit=${limit}&offset=${offset}&fields=${encodeURIComponent(fields)}`;
    const r = await fetch(url);
    if (r.status === 401) throw new Error("Not signed in.");
    if (!r.ok) throw new Error("Animelist error: " + (await r.text()));
    const j = await r.json();
    (j.data || []).forEach(item => rows.push(item));
    if (!j.paging || !j.paging.next) break;
    offset += limit;
  }
  return rows;
}

async function enrichOne(id) {
  const u = `/api/anime/${id}?fields=genres,studios,start_season,num_episodes,media_type`;
  const r = await fetch(u);
  if (!r.ok) return null;
  return r.json();
}

function toDisplayRow(row, details) {
  const n = row.node;
  const ls = row.list_status || {};
  const d = details || {};
  const title = n.title_english || n.title || "—";
  const score = (ls.score && ls.score !== 0) ? ls.score : "—";
  const genresArr = (d.genres || []).slice(0,3).map(g => g.name);
  const studiosArr = (d.studios || []).slice(0,2).map(s => s.name);
  const year = (d.start_season && d.start_season.year) ? d.start_season.year : "";
  const type = d.media_type || n.media_type || "";
  const ep = (typeof d.num_episodes === "number") ? d.num_episodes : (n.num_episodes || "");
  const link = `https://myanimelist.net/anime/${n.id}`;
  return { title, score, genresArr, year, type, ep, studiosArr, link, id: n.id };
}

function render(rows, detailsMap) {
  const tbody = document.querySelector("#tbl tbody");
  tbody.innerHTML = "";
  for (const row of rows) {
    const d = detailsMap.get(row.node.id);
    const v = toDisplayRow(row, d);
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${v.title}</td>
      <td style="text-align:right">${v.score}</td>
      <td>${v.genresArr.join(", ")}</td>
      <td style="text-align:right">${v.year||""}</td>
      <td>${v.type||""}</td>
      <td style="text-align:right">${v.ep||""}</td>
      <td>${v.studiosArr.join(", ")}</td>
      <td><a href="${v.link}" target="_blank">MAL</a></td>`;
    tbody.appendChild(tr);
  }
  document.getElementById("tbl").style.display = "";
}

function download(filename, text, mime) {
  const blob = new Blob([text], { type: mime || "text/plain;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function generateCSV(rows, detailsMap) {
  const headers = ["Title","My Score","Genres","Year","Type","Ep","Studios","Link"];
  const lines = [headers.join(",")];
  for (const row of rows) {
    const v = toDisplayRow(row, detailsMap.get(row.node.id));
    const title = `"${(v.title || "").replace(/"/g, '""')}"`;
    const score = v.score === "—" ? "" : v.score;
    const genres = `"${v.genresArr.join("; ").replace(/"/g, '""')}"`;
    const studios = `"${v.studiosArr.join("; ").replace(/"/g, '""')}"`;
    const year = v.year || "";
    const type = `"${(v.type||"").replace(/"/g, '""')}"`;
    const ep = v.ep || "";
    const link = v.link;
    lines.push([title, score, genres, year, type, ep, studios, link].join(","));
  }
  return lines.join("\n");
}

function generateMarkdown(rows, detailsMap) {
  const header = "| Title | My Score | Genres | Year | Type | Ep | Studios | Link |\n|---|---:|---|---:|---|---:|---|---|";
  const lines = [header];
  for (const row of rows) {
    const v = toDisplayRow(row, detailsMap.get(row.node.id));
    const score = v.score === "—" ? "—" : String(v.score);
    lines.push(`| ${v.title} | ${score} | ${v.genresArr.join(", ")} | ${v.year||""} | ${v.type||""} | ${v.ep||""} | ${v.studiosArr.join(", ")} | ${v.link} |`);
  }
  return lines.join("\n");
}

// ——— main actions ———
document.getElementById("load").addEventListener("click", async () => {
  try {
    document.getElementById("status").textContent = "Loading…";
    LAST_ROWS = [];
    LAST_DETAILS = new Map();

    const gateCompleted = document.getElementById("gateCompleted").checked;
    const tagToken = document.getElementById("tagToken").value;

    const items = await fetchAllList();
    LAST_ALL_ITEMS = items.slice(); // keep raw set for diagnostics ✅

    // Filter to exact tag + (optional) completed
    const filt = items.filter(x => {
      const ls = x.list_status || {};
      const hasTag = tokenHasTag(ls, tagToken);
      const done = !gateCompleted || (ls.status && ls.status.toLowerCase() === "completed");
      return hasTag && done;
    });

    // Sort by score desc (0 lowest), then title asc
    const rows = filt.slice().sort((a,b) => {
      const sa = a.list_status.score || 0, sb = b.list_status.score || 0;
      if (sb !== sa) return sb - sa;
      const ta = (a.node.title_english || a.node.title || "").toLowerCase();
      const tb = (b.node.title_english || b.node.title || "").toLowerCase();
      return ta.localeCompare(tb);
    });

    LAST_ROWS = rows;

    // Enrich a safe chunk to avoid rate limits
    const MAX_DETAILS = 50;
    const toEnrich = rows.slice(0, MAX_DETAILS);
    for (const x of toEnrich) {
      const d = await enrichOne(x.node.id);
      if (d) LAST_DETAILS.set(x.node.id, d);
    }

    render(rows, LAST_DETAILS);
    document.getElementById("status").textContent =
      `Loaded ${filt.length} items; showing ${rows.length}. Details fetched for ${LAST_DETAILS.size}.`;
  } catch (e) {
    document.getElementById("status").textContent = e.message || "Error.";
  }
});

// Exports
document.getElementById("exportCsv").addEventListener("click", () => {
  if (!LAST_ROWS.length) return (document.getElementById("status").textContent = "Load the list first.");
  const csv = generateCSV(LAST_ROWS, LAST_DETAILS);
  download("rewatch_list.csv", csv, "text/csv;charset=utf-8;");
});

document.getElementById("exportMd").addEventListener("click", () => {
  if (!LAST_ROWS.length) return (document.getElementById("status").textContent = "Load the list first.");
  const md = generateMarkdown(LAST_ROWS, LAST_DETAILS);
  download("rewatch_list.md", md, "text/markdown;charset=utf-8;");
});

document.getElementById("copyMd").addEventListener("click", async () => {
  if (!LAST_ROWS.length) return (document.getElementById("status").textContent = "Load the list first.");
  const md = generateMarkdown(LAST_ROWS, LAST_DETAILS);
  try {
    await navigator.clipboard.writeText(md);
    document.getElementById("status").textContent = "Markdown copied to clipboard.";
  } catch {
    const ta = document.createElement("textarea");
    ta.value = md;
    document.body.appendChild(ta);
    ta.select();
    const ok = document.execCommand("copy");
    ta.remove();
    document.getElementById("status").textContent = ok ? "Markdown copied (fallback)." : "Clipboard blocked — use Download Markdown instead.";
  }
});

// ——— diagnostics ———
document.getElementById("debug").addEventListener("click", () => {
  if (!LAST_ALL_ITEMS.length) {
    document.getElementById("status").textContent = "Load the list first.";
    return;
  }
  const tagToken = document.getElementById("tagToken").value.toLowerCase();

  // count all tag tokens seen (across entire list)
  const tagCounts = new Map();   // token -> count
  const statusCounts = new Map(); // for items that match the selected tag
  for (const it of LAST_ALL_ITEMS) {
    const tags = splitTags(it.list_status).map(t => t.toLowerCase());
    for (const t of tags) tagCounts.set(t, (tagCounts.get(t)||0) + 1);
    if (tags.includes(tagToken)) {
      const st = statusName(it.list_status && it.list_status.status);
      statusCounts.set(st, (statusCounts.get(st)||0) + 1);
    }
  }
  const tagLines = [...tagCounts.entries()].sort((a,b)=>b[1]-a[1]).map(([t,c])=>`${t||"(empty)"}: ${c}`).join(" • ");
  const stLines  = [...statusCounts.entries()].sort((a,b)=>b[1]-a[1]).map(([s,c])=>`${s}: ${c}`).join(" • ");

  document.getElementById("status").textContent =
    `Tag variants seen → ${tagLines || "none"}  ||  By status for “${tagToken}” → ${stLines || "none"}`;
});

document.getElementById("missing").addEventListener("click", () => {
  if (!LAST_ALL_ITEMS.length) {
    document.getElementById("status").textContent = "Load the list first.";
    return;
  }
  const gateCompleted = document.getElementById("gateCompleted").checked;
  const tagToken = document.getElementById("tagToken").value.toLowerCase();

  const reasons = { notCompleted: [], tagMismatch: [] };
  for (const it of LAST_ALL_ITEMS) {
    const ls = it.list_status || {};
    const tags = splitTags(ls).map(t => t.toLowerCase());
    const hasTag = tags.includes(tagToken);
    const done = ls.status && ls.status.toLowerCase() === "completed";
    if (!hasTag) reasons.tagMismatch.push(it.node.title_english || it.node.title || `ID ${it.node.id}`);
    else if (gateCompleted && !done) reasons.notCompleted.push(it.node.title_english || it.node.title || `ID ${it.node.id}`);
  }

  const top5 = (arr) => arr.slice(0,5).join(" | ") + (arr.length > 5 ? ` …(+${arr.length-5})` : "");
  document.getElementById("status").textContent =
    `Excluded — Tag mismatch: ${reasons.tagMismatch.length} (e.g., ${top5(reasons.tagMismatch)}) | Not completed: ${reasons.notCompleted.length} (e.g., ${top5(reasons.notCompleted)})`;
});
</script>
</body>
</html>
